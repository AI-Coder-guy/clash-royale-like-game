<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Royale — You vs Computer (Cartoon 3D)</title>
<style>
  /* ---------------- Theme & Layout ---------------- */
  :root{
    --bg-top: #bce7ff;
    --bg-bottom: #f7fbff;
    --card-bg: #fff;
    --accent: #2b8cff;
    --muted: #6b7280;
    --tower-col:#ffcc66;
    --tower-king:#ff8b8b;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));-webkit-font-smoothing:antialiased}
  .wrap{max-width:1100px;margin:18px auto;padding:10px}
  .container{display:flex;gap:12px;background:linear-gradient(180deg,#fff,#fbfdff);border-radius:12px;box-shadow:0 12px 30px rgba(12,24,40,0.08);overflow:hidden}
  header{display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #eef3ff}
  header h1{margin:0;font-size:18px}
  .status{display:flex;gap:16px;align-items:center}
  .elixir{display:flex;flex-direction:column;align-items:center;font-size:13px}
  .bar{width:180px;height:12px;background:#e9eef8;border-radius:999px;overflow:hidden;margin-top:6px}
  .fill{height:100%;background:linear-gradient(90deg,var(--accent),#80c7ff);width:0%}
  main{display:flex;align-items:stretch;padding:14px}
  /* ---------------- Arena (cartoon-ish 3D) ---------------- */
  .arena-wrap{flex:1;display:flex;flex-direction:column;align-items:center}
  .arena{width:820px;height:600px;border-radius:12px;background:linear-gradient(180deg,#dff6ff,#e9f9ff);position:relative;box-shadow:0 10px 28px rgba(12,20,40,0.06);perspective:900px;overflow:hidden}
  .field-floor{position:absolute;left:0;right:0;bottom:0;height:60%;background:linear-gradient(180deg,#bfefff, rgba(255,255,255,0.02));transform-origin:center top;transform:rotateX(12deg) translateZ(-40px);box-shadow:inset 0 -12px 30px rgba(0,0,0,0.04)}
  .lane{position:absolute;left:0;right:0;height:50%;display:flex;justify-content:space-between;align-items:center;padding:18px 26px;box-sizing:border-box}
  #lane-top{top:0}
  #lane-bottom{bottom:0}
  .lane:before{content:"";position:absolute;left:0;right:0;top:50%;height:2px;background:linear-gradient(90deg, rgba(0,0,0,0.06), rgba(255,255,255,0.02));transform:translateY(-50%)}
  /* towers */
  .tower{width:108px;height:108px;border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;font-weight:900;position:relative;box-shadow:0 18px 36px rgba(10,20,40,0.08)}
  .tower .model{width:70px;height:70px;border-radius:10px;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;box-shadow:inset 0 -6px 12px rgba(0,0,0,0.08)}
  .tower.king{width:136px;height:136px}
  .tower .hp{position:absolute;bottom:-18px;background:var(--card-bg);padding:4px 8px;border-radius:12px;border:1px solid #eef3ff;font-size:12px;box-shadow:0 8px 18px rgba(6,12,30,0.04)}
  .tower.dead{opacity:0.36;filter:grayscale(70%)}
  .tower.hurt{animation:hit-tower .26s ease}
  @keyframes hit-tower{0%{transform:translateY(0)}50%{transform:translateY(-6px)}100%{transform:translateY(0)}}

  /* units (cartoon tokens) */
  #units-layer{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none}
  .unit{position:absolute;width:46px;height:46px;transform-style:preserve-3d;pointer-events:none}
  .unit .token{width:46px;height:34px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:900;color:#fff;box-shadow:0 10px 18px rgba(8,12,30,0.12)}
  .unit .shadow{position:absolute;left:50%;transform:translateX(-50%);bottom:-6px;width:32px;height:8px;border-radius:50%;background:radial-gradient(ellipse at center, rgba(2,8,20,0.12), rgba(2,8,20,0.02));filter:blur(1.6px)}
  .unit .hpbar{position:absolute;left:50%;transform:translateX(-50%);top:38px;width:48px;height:6px;border-radius:6px;background:#fafafa;border:1px solid rgba(0,0,0,0.06);overflow:hidden}
  .unit .hpfill{height:100%;background:linear-gradient(90deg,#8ef3a6,#2b8cff);width:100%;transition:width .12s linear}

  /* particles canvas */
  #particles{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}

  /* sidebar (cards) */
  .sidebar{width:300px;padding:12px;background:var(--card-bg);border-left:1px solid #eef5ff;display:flex;flex-direction:column;gap:12px}
  .cards{display:flex;gap:10px;align-items:center;justify-content:flex-start}
  .card-slot{width:72px;height:96px;border-radius:10px;background:linear-gradient(180deg,#fff,#f7fbff);display:flex;flex-direction:column;align-items:center;justify-content:space-between;padding:8px;box-shadow:0 10px 22px rgba(8,12,30,0.06);cursor:pointer;border:2px solid transparent;position:relative}
  .card-slot.locked{opacity:0.5;transform:scale(.98);cursor:not-allowed}
  .card-slot .icon{width:48px;height:48px;border-radius:8px;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900}
  .card-slot .label{font-size:12px;font-weight:800}
  .card-slot .cost{font-size:12px;font-weight:800}
  .controls{display:flex;justify-content:space-between;align-items:center}
  .btn{background:var(--accent);color:#fff;padding:8px 10px;border-radius:8px;border:0;cursor:pointer}
  .log{height:110px;overflow:auto;padding:8px;border-radius:8px;background:#fff;border:1px solid #f1f5f9;font-size:13px}

  /* small responsive */
  @media (max-width:980px){ .container{flex-direction:column} .sidebar{width:100%} .arena{width:100%;height:520px} }
</style>
</head>
<body>
<div class="wrap">
  <div class="container" role="application" aria-label="Mini Royale">
    <div class="arena-wrap">
      <header style="width:100%;display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
        <div style="display:flex;gap:10px;align-items:center">
          <h1 style="margin:0">Mini Royale — You vs Computer</h1>
          <div style="font-size:12px;color:var(--muted)">Cartoon 3D style • Single file</div>
        </div>

        <div class="status">
          <div style="text-align:right">
            <div style="font-size:12px;color:var(--muted)">Opponent</div>
            <div style="font-weight:800">Computer</div>
          </div>
          <div class="elixir">
            <div style="font-weight:700">Elixir</div>
            <div class="bar" aria-hidden="true"><div class="fill" id="elixir-fill"></div></div>
            <div id="elixir-text" style="font-weight:700">0 / 10</div>
          </div>
        </div>
      </header>

      <div class="arena" id="arena" tabindex="0">
        <div class="field-floor"></div>

        <!-- top lane -->
        <div id="lane-top" class="lane" data-y="120">
          <div class="tower" data-side="ai" data-pos="left" id="ai-left-tower">
            <div class="model" style="background:linear-gradient(180deg,#8b5cf6,#6e3bd6)">L</div>
            <div class="hp" id="ai-left-hp">HP</div>
          </div>

          <div class="tower king" data-side="ai" data-pos="king" id="ai-king-tower">
            <div class="model" style="background:linear-gradient(180deg,#ff7a7a,#ff4b4b)">K</div>
            <div class="hp" id="ai-king-hp">HP</div>
          </div>

          <div class="tower" data-side="ai" data-pos="right" id="ai-right-tower">
            <div class="model" style="background:linear-gradient(180deg,#2b8cff,#0066ff)">R</div>
            <div class="hp" id="ai-right-hp">HP</div>
          </div>
        </div>

        <!-- bottom lane -->
        <div id="lane-bottom" class="lane" data-y="480" style="align-items:flex-end;">
          <div class="tower" data-side="player" data-pos="left" id="player-left-tower">
            <div class="model" style="background:linear-gradient(180deg,#2b8cff,#0066ff)">L</div>
            <div class="hp" id="player-left-hp">HP</div>
          </div>

          <div class="tower king" data-side="player" data-pos="king" id="player-king-tower">
            <div class="model" style="background:linear-gradient(180deg,#ffb37a,#ff8b3b)">K</div>
            <div class="hp" id="player-king-hp">HP</div>
          </div>

          <div class="tower" data-side="player" data-pos="right" id="player-right-tower">
            <div class="model" style="background:linear-gradient(180deg,#8b5cf6,#6e3bd6)">R</div>
            <div class="hp" id="player-right-hp">HP</div>
          </div>
        </div>

        <div id="units-layer"></div>
        <canvas id="particles"></canvas>

        <div id="banner" style="position:absolute;left:50%;top:48%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:999px;background:rgba(255,255,255,0.95);font-weight:900;display:none;box-shadow:0 12px 30px rgba(0,0,0,0.08)"></div>
      </div>
    </div>

    <aside class="sidebar" role="region" aria-label="Controls">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:900">Your Cards</div>
        <div style="font-size:12px;color:var(--muted)">Cards rotate every 6s • Click a card then click bottom lane</div>
      </div>

      <div class="cards" id="cards"></div>

      <div style="font-size:13px;color:var(--muted)">Elixir regens automatically. AI has its own elixir.</div>

      <div class="log" id="log"></div>

      <div class="controls" style="margin-top:6px">
        <div style="display:flex;gap:8px;align-items:center">
          <button id="restart" class="btn">Restart</button>
          <button id="sound" class="btn" style="background:#fff;color:#000;border:1px solid #eef3ff">Sound: On</button>
        </div>
        <div style="text-align:right">
          <div style="font-size:12px;color:var(--muted)">Your Wins (local)</div>
          <div id="best" style="font-weight:800">0</div>
        </div>
      </div>
    </aside>
  </div>
</div>

<script>
/* ---------------- Utilities ---------------- */
function now(){ return performance.now()/1000; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rand(a,b){ return Math.random()*(b-a)+a; }
function randInt(a,b){ return Math.floor(rand(a,b+1)); }
function distance(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }

/* ---------------- Config & Templates ---------------- */
const CONFIG = {
  elixirMax: 10, elixirRegenRate: 1/2.2, // per sec
  lanes: ['left','right'], cardRotationInterval: 6, visibleSlots: 4
};

const TEMPLATES = {
  'Knight':       {hp:600, atk:100, range:26, atkSpeed:1.1, speed:34, cost:4, color:'#f59e0b', role:'melee'},
  'Archer':       {hp:110, atk:45, range:130, atkSpeed:1.0, speed:52, cost:3, color:'#6b8bff', role:'ranged'},
  'Giant':        {hp:1500,atk:160,range:36,atkSpeed:1.6,speed:22,cost:6,color:'#8b5cf6',role:'tank'},
  'Goblin':       {hp:120, atk:48, range:28, atkSpeed:0.9, speed:84, cost:2, color:'#6de39a', role:'melee'},
  'Wizard':       {hp:180, atk:95, range:140, atkSpeed:1.5, speed:36, cost:5, color:'#10b981', role:'rangedAoE'},
  'Musketeer':    {hp:200, atk:120, range:160, atkSpeed:1.2, speed:38, cost:4, color:'#4f7cff', role:'ranged'},
  'Skeletons':    {hp:60, atk:22, range:28, atkSpeed:0.9, speed:82, cost:1, color:'#cfcfcf', role:'swarm', count:3},
  'Hog Rider':    {hp:720, atk:160, range:34, atkSpeed:1.2, speed:78, cost:4, color:'#d97a1a', role:'bridge'}
};

/* ---------------- DOM Refs ---------------- */
const arena = document.getElementById('arena');
const unitsLayer = document.getElementById('units-layer');
const particlesCanvas = document.getElementById('particles');
const elixirFill = document.getElementById('elixir-fill');
const elixirText = document.getElementById('elixir-text');
const cardsDiv = document.getElementById('cards');
const logEl = document.getElementById('log');
const banner = document.getElementById('banner');
const restartBtn = document.getElementById('restart');
const soundBtn = document.getElementById('sound');
const bestEl = document.getElementById('best');

/* ---------------- Audio (tiny oscillator beeps) ---------------- */
let audioOn = true;
soundBtn.addEventListener('click', ()=>{ audioOn = !audioOn; soundBtn.textContent = 'Sound: ' + (audioOn?'On':'Off'); if(audioOn && Audio.ctx.state==='suspended') Audio.ctx.resume(); });
const Audio = (function(){
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  function beep(freq=440, t=0.06, type='sine', vol=0.06){
    if(!audioOn) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = 0;
    o.connect(g); g.connect(ctx.destination);
    const nowT = ctx.currentTime;
    g.gain.linearRampToValueAtTime(vol, nowT + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, nowT + t);
    o.start(nowT); o.stop(nowT + t + 0.02);
  }
  return {beep, ctx};
})();

/* ---------------- Particles (simple) ---------------- */
const pc = particlesCanvas, pctx = pc.getContext('2d');
let particles = [];
function resizeParticles(){ pc.width = arena.clientWidth; pc.height = arena.clientHeight; pc.style.left = arena.offsetLeft + 'px'; pc.style.top = arena.offsetTop + 'px'; }
window.addEventListener('resize', resizeParticles); resizeParticles();
function spawnParticles(x,y,color,count=12,spread=26){
  for(let i=0;i<count;i++){
    particles.push({x,y,vx:rand(-spread,spread),vy:rand(-spread,spread),age:0,life:rand(0.4,0.9),color,size:rand(2,6)});
  }
}
function updateParticles(dt){
  pctx.clearRect(0,0,pc.width,pc.height);
  const rect = arena.getBoundingClientRect();
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; p.age += dt;
    if(p.age >= p.life){ particles.splice(i,1); continue; }
    p.x += p.vx * dt * 60; p.y += p.vy * dt * 60;
    const alpha = 1 - (p.age / p.life);
    pctx.globalAlpha = alpha;
    pctx.fillStyle = p.color;
    pctx.beginPath();
    pctx.arc(p.x - rect.left, p.y - rect.top, p.size, 0, Math.PI*2);
    pctx.fill();
  }
  pctx.globalAlpha = 1;
}

/* ---------------- Game classes ---------------- */
class Tower {
  constructor(side,pos,dom,stats){
    this.side=side; this.pos=pos; this.dom=dom;
    this.maxHp = stats.hp; this.hp = stats.hp; this.atk=stats.atk; this.range=stats.range; this.atkSpeed=stats.atkSpeed;
    this.cool = 0;
    this.updateDOM();
  }
  getCenter(){ const r = this.dom.getBoundingClientRect(); return {x:r.left + r.width/2, y: r.top + r.height/2}; }
  takeDamage(d){
    if(this.hp<=0) return;
    this.hp = Math.max(0, this.hp - d); this.updateDOM();
    this.dom.classList.add('hurt'); setTimeout(()=>this.dom.classList.remove('hurt'),240);
    spawnParticles(this.getCenter().x, this.getCenter().y, 'rgba(255,180,60,0.95)', 18, 32);
    Audio.beep(220,0.08,'square',0.08);
    if(this.hp<=0){ this.dom.classList.add('dead'); spawnParticles(this.getCenter().x,this.getCenter().y,'rgba(200,40,40,0.95)',40,60); }
  }
  updateDOM(){ const el = this.dom.querySelector('.hp'); if(el) el.textContent = 'HP: ' + Math.floor(this.hp); }
  update(dt, units){
    if(this.hp<=0) return;
    this.cool -= dt;
    let best = null, bestD=1e9;
    const c = this.getCenter();
    for(const u of units){ if(!u.alive || u.side===this.side) continue; const d = distance(u.x,u.y,c.x,c.y); if(d<=this.range && d<bestD){ best=u; bestD=d; } }
    if(best && this.cool<=0){ best.takeDamage(this.atk); this.cool=this.atkSpeed; Audio.beep(360,0.06,'sine',0.06); spawnParticles(best.x,best.y,'rgba(255,220,60,0.9)',8,16); }
  }
  get alive(){ return this.hp>0; }
}

/* Unit (simple object with DOM element) */
class Unit {
  constructor(id, name, side, x, y, template){
    this.id=id; this.name=name; this.side=side; this.x=x; this.y=y; this.template=template;
    this.hp = template.hp; this.maxHp = template.hp; this.atk = template.atk; this.range = template.range; this.atkSpeed = template.atkSpeed; this.speed = template.speed;
    this.cost = template.cost; this.color = template.color; this.role = template.role; this.count = template.count || 1;
    this.cool = 0; this.alive=true; this.target=null;
    this.dom = this.makeDOM();
    this.render(); 
  }
  makeDOM(){
    const el = document.createElement('div'); el.className='unit';
    const token = document.createElement('div'); token.className='token'; token.style.background = this.color; token.textContent = this.name.split(' ').map(s=>s[0]).slice(0,2).join('');
    const shadow = document.createElement('div'); shadow.className='shadow';
    const hpbar = document.createElement('div'); hpbar.className='hpbar'; const hpfill = document.createElement('div'); hpfill.className='hpfill'; hpbar.appendChild(hpfill);
    el.appendChild(token); el.appendChild(shadow); el.appendChild(hpbar);
    unitsLayer.appendChild(el);
    this.token = token; this.hpfill = hpfill; return el;
  }
  takeDamage(d){
    if(!this.alive) return;
    this.hp = Math.max(0, this.hp - d); this.hpfill.style.width = (this.hp/this.maxHp*100) + '%';
    this.token.style.transform = 'translateZ(20px) scale(1.03)'; setTimeout(()=>this.token.style.transform='translateZ(12px)',80);
    Audio.beep(720,0.04,'triangle',0.04); spawnParticles(this.x,this.y,'rgba(255,120,60,0.98)',6,14);
    if(this.hp<=0) this.die();
  }
  die(){
    if(!this.alive) return;
    this.alive=false;
    this.token.style.transform='translateZ(6px) scale(0.86) rotateX(18deg)';
    this.dom.style.opacity='0';
    Audio.beep(160,0.18,'sawtooth',0.08); spawnParticles(this.x,this.y,'rgba(200,40,40,0.96)',10,26);
    setTimeout(()=>{ if(this.dom.parentElement) this.dom.parentElement.removeChild(this.dom); },420);
  }
  render(){ const rect = arena.getBoundingClientRect(); this.dom.style.left = (this.x - rect.left) + 'px'; this.dom.style.top = (this.y - rect.top) + 'px'; }
}

/* ---------------- Game Core ---------------- */
class Game {
  constructor(){
    this.reset();
    this.loop = this.loop.bind(this);
    this.last = now(); this.raf = requestAnimationFrame(this.loop);
    this.cardRotationTimer = 0;
  }
  reset(){
    // clear DOM layers
    unitsLayer.innerHTML=''; particles=[]; this.units=[];
    // towers
    const towerBase = {left:{hp:900,atk:85,range:120,atkSpeed:1.0}, right:{hp:900,atk:85,range:120,atkSpeed:1.0}, king:{hp:2200,atk:160,range:140,atkSpeed:1.4}};
    this.towers = {
      'ai-left': new Tower('ai','left', document.getElementById('ai-left-tower'), towerBase.left),
      'ai-king': new Tower('ai','king', document.getElementById('ai-king-tower'), towerBase.king),
      'ai-right': new Tower('ai','right', document.getElementById('ai-right-tower'), towerBase.right),
      'player-left': new Tower('player','left', document.getElementById('player-left-tower'), towerBase.left),
      'player-king': new Tower('player','king', document.getElementById('player-king-tower'), towerBase.king),
      'player-right': new Tower('player','right', document.getElementById('player-right-tower'), towerBase.right)
    };
    // spawn points
    const rect = arena.getBoundingClientRect();
    this.spawnPoints = {
      'player-left': {x: rect.left + rect.width * 0.12, y: rect.top + parseFloat(document.getElementById('lane-bottom').getAttribute('data-y'))},
      'player-right': {x: rect.left + rect.width * 0.88, y: rect.top + parseFloat(document.getElementById('lane-bottom').getAttribute('data-y'))},
      'ai-left': {x: rect.left + rect.width * 0.12, y: rect.top + parseFloat(document.getElementById('lane-top').getAttribute('data-y'))},
      'ai-right': {x: rect.left + rect.width * 0.88, y: rect.top + parseFloat(document.getElementById('lane-top').getAttribute('data-y'))}
    };
    // players
    this.player = {elixir:5, maxElixir:CONFIG.elixirMax};
    this.ai = {elixir:5, maxElixir:CONFIG.elixirMax, lastTry:0};
    // deck (8 cards) and visible rotating slots
    this.deck = ['Knight','Archer','Giant','Goblin','Wizard','Musketeer','Skeletons','Hog Rider'];
    this.rotationIndex = 0;
    this.visibleSlots = [];
    for(let i=0;i<CONFIG.visibleSlots;i++) this.visibleSlots.push(this.deck[i]);
    this.selectedCard = null;
    this.gameOver=false;
    this.startTime = now();
    this.log('Game started — good luck!');
    this.updateUI();
    buildCardsUI(); resizeParticles();
  }

  log(msg){
    const line = document.createElement('div'); line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`; logEl.prepend(line);
  }

  updateUI(){
    const pct = (this.player.elixir / this.player.maxElixir) * 100;
    elixirFill.style.width = pct + '%';
    elixirText.textContent = `${Math.floor(this.player.elixir)} / ${this.player.maxElixir}`;
    // tower hp DOM already handled by tower.updateDOM
  }

  attemptSpawn(side,lane,name){
    const tmpl = TEMPLATES[name];
    if(!tmpl) return;
    if(side==='player' && this.player.elixir < tmpl.cost){ this.flash('Not enough elixir'); return false; }
    const key = `${side}-${lane}`; const pos = this.spawnPoints[key];
    if(!pos){ this.flash('Cannot deploy there'); return false; }
    // spend elixir
    if(side==='player'){ this.player.elixir -= tmpl.cost; this.updateUI(); }
    // spawn one or multiple units (for Skeletons)
    const count = tmpl.count || 1;
    for(let i=0;i<count;i++){
      const x = pos.x + rand(-12,12); const y = pos.y + rand(-6,6);
      const id = Math.floor(Math.random()*1e9);
      const unit = new Unit(id, name, side, x, y, tmpl);
      this.units.push(unit);
    }
    Audio.beep(320,0.06,'sine',0.06);
    this.log(`${side==='player'?'You':'AI'} deployed ${name}`);
    return true;
  }

  aiThink(dt){
    const t = now();
    if(t - this.ai.lastTry < 1.0) return; this.ai.lastTry = t;
    // simple heuristics: if AI elixir enough, spawn a card
    const affordable = Object.keys(TEMPLATES).filter(k=>TEMPLATES[k].cost <= this.ai.elixir);
    if(affordable.length===0) return;
    // prefer tanks if player king low
    let choice = affordable[randInt(0,affordable.length-1)];
    if(this.towers['player-king'].hp < 1000 && this.ai.elixir>=5 && Math.random()<0.6) choice='Giant';
    // choose lane weaker side
    const lane = (this.towers['player-left'].hp < this.towers['player-right'].hp) ? 'left' : 'right';
    const tmpl = TEMPLATES[choice];
    if(tmpl && tmpl.cost <= this.ai.elixir){
      this.ai.elixir -= tmpl.cost;
      this.attemptSpawn('ai', lane, choice);
    }
  }

  rotateCards(dt){
    this.cardRotationTimer = (this.cardRotationTimer || 0) + dt;
    if(this.cardRotationTimer >= CONFIG.cardRotationInterval){
      // rotate deck: bring next card into rightmost visible slot
      this.cardRotationTimer = 0;
      this.rotationIndex = (this.rotationIndex + 1) % this.deck.length;
      // recompute visible slots as slice from rotationIndex
      this.visibleSlots = [];
      for(let i=0;i<CONFIG.visibleSlots;i++){
        this.visibleSlots.push(this.deck[(this.rotationIndex + i) % this.deck.length]);
      }
      buildCardsUI();
    }
  }

  update(dt){
    // regen elixir
    this.player.elixir = clamp(this.player.elixir + CONFIG.elixirRegenRate * dt, 0, this.player.maxElixir);
    this.ai.elixir = clamp(this.ai.elixir + CONFIG.elixirRegenRate * dt, 0, this.ai.maxElixir);
    this.updateUI();

    // rotate cards
    this.rotateCards(dt);

    // AI decisions
    this.aiThink(dt);

    // towers attack units
    Object.values(this.towers).forEach(t => t.update(dt, this.units));

    // units logic
    for(const u of this.units){
      if(!u.alive) continue;
      // find closest enemy unit
      let nearest = null, nd = 1e9;
      for(const o of this.units){
        if(!o.alive || o.side===u.side) continue;
        const d = distance(u.x,u.y,o.x,o.y);
        if(d<nd){ nd=d; nearest=o; }
      }
      // find nearest enemy tower
      let nearestTower = null, td = 1e9;
      for(const k in this.towers){ const tw = this.towers[k]; if(!tw.alive || tw.side===u.side) continue; const c = tw.getCenter(); const d = distance(u.x,u.y,c.x,c.y); if(d<td){ td=d; nearestTower=tw; } }
      // decide target
      if(nearest && distance(u.x,u.y,nearest.x,nearest.y) <= u.range + 6){ u.target = nearest; }
      else if(nearestTower && td <= u.range + 12) u.target = nearestTower;
      else if(nearest && nd < td + 40) u.target = nearest;
      else u.target = nearestTower || null;

      // action
      if(u.target){
        const tx = (u.target instanceof Tower) ? u.target.getCenter().x : u.target.x;
        const ty = (u.target instanceof Tower) ? u.target.getCenter().y : u.target.y;
        const d = distance(u.x,u.y,tx,ty);
        if(d > u.range + 6){
          // move toward
          const dx = tx - u.x, dy = ty - u.y; const len = Math.hypot(dx,dy)||1;
          u.x += (dx/len) * u.speed * dt;
          u.y += (dy/len) * u.speed * dt;
        } else {
          if(u.cool <= 0){
            if(u.target instanceof Tower) u.target.takeDamage(u.atk);
            else u.target.takeDamage(u.atk);
            u.cool = u.atkSpeed;
            spawnParticles(tx,ty,'rgba(255,220,60,0.95)',6,18);
            Audio.beep(720,0.04,'triangle',0.04);
          }
        }
      } else {
        // push forward toward opponent side
        const dir = u.side==='player' ? -1 : 1;
        u.y += dir * u.speed * dt;
        // slight x correction toward center
        const rect = arena.getBoundingClientRect();
        const centerX = rect.left + rect.width*0.5;
        u.x += (centerX - u.x) * 0.002 * dt * 60;
      }
      u.cool -= dt;

      // collision stopping: if close to opposing unit, keep fighting (prevent passing)
      for(const o of this.units){
        if(!o.alive || o.side===u.side || o===u) continue;
        const d = distance(u.x,u.y,o.x,o.y);
        if(d < 30){
          // push slightly apart and target each other
          const ang = Math.atan2(u.y-o.y, u.x-o.x);
          u.x += Math.cos(ang)*0.6; u.y += Math.sin(ang)*0.6;
          o.x -= Math.cos(ang)*0.6; o.y -= Math.sin(ang)*0.6;
          if(!u.target) u.target = o; if(!o.target) o.target = u;
        }
      }
      // bounds clamp within arena
      const rect = arena.getBoundingClientRect();
      u.x = clamp(u.x, rect.left+12, rect.right-12);
      u.y = clamp(u.y, rect.top+12, rect.bottom-12);
      u.render();
    }

    // remove dead units from array
    this.units = this.units.filter(u => u.alive);

    // update particles
    updateParticles(dt);

    // check towers for victory
    if(!this.towers['ai-king'].alive) this.endGame('player');
    if(!this.towers['player-king'].alive) this.endGame('ai');
  }

  render(dt){}
  
  loop(){
    const t = now(); let dt = t - this.last; if(dt>0.2) dt=0.2; this.last = t;
    this.update(dt); this.render(dt);
    if(!this.gameOver) this.raf = requestAnimationFrame(()=>this.loop());
  }

  flash(msg, t=1000){ banner.style.display='block'; banner.textContent = msg; setTimeout(()=>banner.style.display='none', t); }

  endGame(winner){
    if(this.gameOver) return;
    this.gameOver=true;
    this.flash(winner==='player'?'Victory!':'Defeat', 3000);
    this.log(`${winner.toUpperCase()} wins!`);
    if(winner==='player'){ Audio.beep(880,0.12,'sine',0.12); const prev = parseInt(localStorage.getItem('mini_best')||'0',10); localStorage.setItem('mini_best', String(prev+1)); bestEl.textContent = prev+1; }
    else Audio.beep(160,0.16,'sawtooth',0.09);
    setTimeout(()=>cancelAnimationFrame(this.raf), 700);
  }
}

/* ---------------- Helper functions for UI & spawn ---------------- */
function spawnParticles(x,y,color,count=12,spread=26){
  for(let i=0;i<count;i++) particles.push({x,y,vx:rand(-spread,spread),vy:rand(-spread,spread),age:0,life:rand(0.3,0.9),color,size:rand(2,6)});
}

/* Build card UI (visibleSlots) */
function buildCardsUI(){
  cardsDiv.innerHTML = '';
  GAME.visibleSlots.forEach((name, idx) => {
    const tmpl = TEMPLATES[name];
    const slot = document.createElement('div'); slot.className='card-slot';
    if(GAME.player.elixir < tmpl.cost) slot.classList.add('locked');
    slot.innerHTML = `<div class="icon" style="background:${tmpl.color}">${name.split(' ').map(s=>s[0]).slice(0,2).join('')}</div>
                      <div class="label">${name}</div><div class="cost">${tmpl.cost}✦</div>`;
    slot.addEventListener('click', ()=>{
      // select this card for spawn
      GAME.selectedCard = name;
      Array.from(cardsDiv.children).forEach(c=>c.style.borderColor='transparent');
      slot.style.borderColor='rgba(43,140,255,0.28)';
      GAME.log('Selected ' + name + ' — click bottom lane to deploy');
    });
    cardsDiv.appendChild(slot);
  });
}

/* Recompute spawn points when resized */
function recomputeSpawnPoints(){ const rect = arena.getBoundingClientRect(); GAME.spawnPoints = { 'player-left': {x: rect.left + rect.width*0.12, y: rect.top + parseFloat(document.getElementById('lane-bottom').getAttribute('data-y'))}, 'player-right': {x: rect.left + rect.width*0.88, y: rect.top + parseFloat(document.getElementById('lane-bottom').getAttribute('data-y'))}, 'ai-left': {x: rect.left + rect.width*0.12, y: rect.top + parseFloat(document.getElementById('lane-top').getAttribute('data-y'))}, 'ai-right': {x: rect.left + rect.width*0.88, y: rect.top + parseFloat(document.getElementById('lane-top').getAttribute('data-y'))} }; resizeParticles(); }
window.addEventListener('resize', recomputeSpawnPoints);

/* ---------------- Input: click bottom lane to spawn ---------------- */
arena.addEventListener('click', (ev)=>{
  if(GAME.gameOver) return;
  if(!GAME.selectedCard){ GAME.flash('Select a card first'); return; }
  const rect = arena.getBoundingClientRect();
  const relY = (ev.clientY - rect.top) / rect.height;
  if(relY < 0.45){ GAME.flash('You can only deploy on your side (bottom)'); return; }
  const relX = (ev.clientX - rect.left) / rect.width;
  const lane = relX < 0.5 ? 'left' : 'right';
  const name = GAME.selectedCard;
  const ok = GAME.attemptSpawn('player', lane, name);
  if(ok){ GAME.selectedCard = null; Array.from(cardsDiv.children).forEach(c=>c.style.borderColor='transparent'); buildCardsUI(); }
});

/* ---------------- Init game ---------------- */
let GAME = new Game();
GAME.log('Ready — use the cards below (or let them rotate every 6s).');
buildCardsUI();

/* UI: restart */
restartBtn.addEventListener('click', ()=>{
  cancelAnimationFrame(GAME.raf);
  GAME = new Game();
});

/* load best wins */
bestEl.textContent = localStorage.getItem('mini_best') || '0';

/* small ticking animation for card rotation timer visual (keeps UI updated) */
(function uiTicker(){
  // update card locks (cost)
  buildCardsUI();
  requestAnimationFrame(uiTicker);
})();

</script>
</body>
</html>

